;; Implement map using `first`, `rest`, and `cons` in Clojure.

;; Suppose you get 25% cash back on a purchase of $75, 15% cash back on a 
;; purchase of $50, 11% cash back on a purchase of $45, 10% cash back on a 
;; purchase of $111, 8% cash back on a purchase of $213, and 5% cash back on
;; a purchase of $2,109.99. How much total cash back did you receive?

;; Pass a set of functions a single collection with map. For example, make
;; three functions, `my-min`, `my-mean`, and `my-max` and put them into a
;; group with `def` (try a `vector` and then a `list`) and another function
;; called `stats` that maps those three functions over a vector of numbers
;; passed to it as an arguemnt.

;; Map a key over a list or vector of hash-maps to get all the values.

;; Use `assoc` in a function.

;; Implement `map` using `reduce`.

;; Implement `filter` using `reduce`.

;; Implement `some` using `reduce`.

;; Implement `take`, `drop`, `take-while`, and `drop-while`.

;; sort [6 3 2 4 5 1] both ascedning and descending. hint: `(doc compare)`

;; Use `some` in a function. Try using `some` to see if a list matches some
;; conditions, and then try to `map` that function over a list of lists to see
;; which of them match the condition, etc.

;; Turn `(concat (take 8 (repeat "na")) '("Batman!"))` into one string. Hint:
;; use `apply` or `reduce`.

;; Use `partial` in a function - define your own version of `inc`.

;; Use `into` in a function.

;; Use `conj` in a function.

;; Use `complement` in a function.

;; Make a lazy seq of Fibonnaci numbers that is 1,000,000 elements long. Get the
;; fourth element.

;; Make a lazy seq of Fibonnaci numbers that is inifinitely long. Get the fourth 
;; element.


  
